"""
PHASE 6: Decision Synthesis Framework
Enhanced decision-making system for APPROACH tab with multi-score integration,
recommendation engine, feasibility assessment, and resource optimization.
"""

import asyncio
from typing import Dict, List, Any, Optional, Tuple, Union
from dataclasses import dataclass, field
from enum import Enum
from datetime import datetime, timedelta
import logging
from pathlib import Path
import json
import numpy as np
from collections import defaultdict

from src.core.base_processor import BaseProcessor
from src.core.entity_cache_manager import get_entity_cache_manager
from src.integration.workflow_aware_scorer import WorkflowAwareGovernmentScorer
from src.integration.government_research_integration import GovernmentResearchIntegration
from src.integration.compliance_roadmap_generator import ComplianceRoadmapGenerator

logger = logging.getLogger(__name__)

class DecisionConfidence(Enum):
    """Decision confidence levels based on data quality and analysis completeness"""
    VERY_HIGH = "very_high"    # 90%+ confidence
    HIGH = "high"              # 75-89% confidence  
    MEDIUM = "medium"          # 50-74% confidence
    LOW = "low"                # 25-49% confidence
    VERY_LOW = "very_low"      # <25% confidence

class RecommendationType(Enum):
    """Types of recommendations generated by the decision engine"""
    PURSUE_IMMEDIATELY = "pursue_immediately"
    PURSUE_WITH_PREPARATION = "pursue_with_preparation"
    CONSIDER_LATER = "consider_later"
    MONITOR_ONLY = "monitor_only"
    AVOID = "avoid"

class ResourceType(Enum):
    """Resource types for allocation optimization"""
    STAFF_TIME = "staff_time"
    BUDGET = "budget"
    EXPERTISE = "expertise"
    PARTNERSHIPS = "partnerships"
    INFRASTRUCTURE = "infrastructure"

@dataclass
class ScoreComponent:
    """Individual score component from different analysis systems"""
    source: str                    # Source system (government, ai_lite, network, etc.)
    raw_score: float              # Raw score (0.0-1.0)
    weighted_score: float         # Score after applying weights
    confidence: float             # Confidence in this score (0.0-1.0)
    metadata: Dict[str, Any]      # Additional context and details
    timestamp: datetime = field(default_factory=datetime.now)

@dataclass
class IntegratedScore:
    """Integrated score combining multiple components"""
    final_score: float                           # Final integrated score (0.0-1.0)
    confidence: DecisionConfidence              # Overall confidence level
    components: List[ScoreComponent]            # Individual score components
    weights: Dict[str, float]                   # Applied weights by source
    integration_method: str                     # How scores were combined
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class FeasibilityAssessment:
    """Comprehensive feasibility assessment for opportunity pursuit"""
    opportunity_id: str
    overall_feasibility: float                  # 0.0-1.0 feasibility score
    confidence: DecisionConfidence
    
    # Feasibility dimensions
    technical_feasibility: float               # Can we execute technically?
    resource_feasibility: float               # Do we have required resources?
    timeline_feasibility: float               # Is timeline achievable?
    compliance_feasibility: float             # Can we meet all requirements?
    strategic_alignment: float                 # Fits organizational strategy?
    
    # Detailed analysis
    strengths: List[str]                       # Key strengths for this opportunity
    weaknesses: List[str]                      # Potential challenges/gaps
    requirements: List[str]                    # Key requirements to fulfill
    risks: List[str]                          # Primary risks and concerns
    mitigation_strategies: List[str]           # Risk mitigation approaches
    
    # Resource requirements
    estimated_effort_hours: Optional[int]      # Estimated total effort
    required_budget: Optional[float]           # Estimated budget requirement
    key_personnel: List[str]                   # Required expertise/roles
    external_partnerships: List[str]           # Needed external relationships
    
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class ResourceAllocation:
    """Optimized resource allocation recommendation"""
    opportunity_id: str
    recommended_allocation: Dict[ResourceType, float]  # Resource allocation percentages
    priority_ranking: int                              # Relative priority (1=highest)
    expected_roi: Optional[float]                      # Expected return on investment
    
    # Timeline optimization
    recommended_timeline: Dict[str, Any]               # Optimized timeline structure
    critical_path: List[str]                          # Critical milestone sequence
    resource_conflicts: List[str]                      # Potential resource conflicts
    
    # Strategic considerations
    strategic_value: float                            # Strategic value score (0.0-1.0)
    risk_adjusted_value: float                        # Value adjusted for risks
    opportunity_cost: Optional[float]                  # Cost of not pursuing others
    
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class DecisionRecommendation:
    """Comprehensive decision recommendation with rationale"""
    opportunity_id: str
    recommendation: RecommendationType
    confidence: DecisionConfidence
    priority_score: float                             # Priority ranking score (0.0-1.0)
    
    # Core components
    integrated_score: IntegratedScore
    feasibility_assessment: FeasibilityAssessment
    resource_allocation: ResourceAllocation
    
    # Decision rationale
    primary_reasons: List[str]                        # Main reasons for recommendation
    supporting_evidence: List[str]                    # Evidence supporting decision
    concerns: List[str]                              # Key concerns or caveats
    conditions: List[str]                            # Conditions for success
    
    # Actionable insights
    immediate_actions: List[str]                      # Actions to take immediately
    preparation_steps: List[str]                      # Preparation required
    success_metrics: List[str]                        # How to measure success
    review_timeline: timedelta                        # When to review decision
    
    metadata: Dict[str, Any] = field(default_factory=dict)
    timestamp: datetime = field(default_factory=datetime.now)

class MultiScoreIntegrationSystem:
    """System for integrating scores from multiple analysis components"""
    
    def __init__(self):
        self.default_weights = {
            'government_scorer': 0.25,      # Government opportunity scoring
            'workflow_aware': 0.20,         # Workflow-aware enhancements
            'ai_lite': 0.15,               # AI Lite quick analysis
            'ai_heavy': 0.20,              # AI Heavy comprehensive analysis
            'network_analysis': 0.10,       # Board network connections
            'compliance': 0.10              # Compliance and risk factors
        }
        
        self.confidence_weights = {
            'data_completeness': 0.30,      # How complete is the data?
            'analysis_depth': 0.25,         # Depth of analysis performed
            'source_reliability': 0.20,     # Reliability of data sources
            'consistency': 0.15,            # Consistency across sources
            'recency': 0.10                # How recent is the data?
        }
    
    async def integrate_scores(self, 
                             opportunity_id: str, 
                             score_components: List[ScoreComponent],
                             custom_weights: Optional[Dict[str, float]] = None) -> IntegratedScore:
        """Integrate multiple score components into final score"""
        try:
            logger.info(f"Integrating scores for opportunity {opportunity_id}")
            
            # Apply custom weights if provided
            weights = custom_weights or self.default_weights
            
            # Validate and normalize weights
            weights = self._normalize_weights(weights, score_components)
            
            # Calculate weighted scores
            weighted_scores = []
            total_weight = 0.0
            
            for component in score_components:
                if component.source in weights:
                    weight = weights[component.source]
                    weighted_score = component.raw_score * weight * component.confidence
                    weighted_scores.append(weighted_score)
                    total_weight += weight * component.confidence
                    
                    # Update component with applied weight
                    component.weighted_score = weighted_score
            
            # Calculate final integrated score
            if total_weight > 0:
                final_score = sum(weighted_scores) / total_weight
            else:
                final_score = 0.0
                logger.warning(f"No valid weighted scores for {opportunity_id}")
            
            # Calculate overall confidence
            confidence = self._calculate_confidence(score_components)
            
            # Integration metadata
            metadata = {
                'integration_timestamp': datetime.now().isoformat(),
                'component_count': len(score_components),
                'total_weight': total_weight,
                'score_variance': np.var([c.raw_score for c in score_components]) if score_components else 0.0
            }
            
            return IntegratedScore(
                final_score=final_score,
                confidence=confidence,
                components=score_components,
                weights=weights,
                integration_method='weighted_confidence_average',
                metadata=metadata
            )
            
        except Exception as e:
            logger.error(f"Error integrating scores for {opportunity_id}: {e}")
            # Return minimal integrated score
            return IntegratedScore(
                final_score=0.0,
                confidence=DecisionConfidence.VERY_LOW,
                components=score_components,
                weights=weights,
                integration_method='error_fallback',
                metadata={'error': str(e)}
            )
    
    def _normalize_weights(self, weights: Dict[str, float], components: List[ScoreComponent]) -> Dict[str, float]:
        """Normalize weights based on available components"""
        available_sources = {c.source for c in components}
        relevant_weights = {k: v for k, v in weights.items() if k in available_sources}
        
        if not relevant_weights:
            # Equal weights for all available sources
            return {source: 1.0/len(available_sources) for source in available_sources}
        
        # Normalize to sum to 1.0
        total = sum(relevant_weights.values())
        return {k: v/total for k, v in relevant_weights.items()}
    
    def _calculate_confidence(self, components: List[ScoreComponent]) -> DecisionConfidence:
        """Calculate overall confidence based on component analysis"""
        if not components:
            return DecisionConfidence.VERY_LOW
        
        # Weighted average of component confidences
        total_confidence = sum(c.confidence for c in components) / len(components)
        
        # Adjust for data completeness and consistency
        score_variance = np.var([c.raw_score for c in components])
        consistency_factor = max(0.0, 1.0 - score_variance)  # Lower variance = higher confidence
        
        adjusted_confidence = total_confidence * consistency_factor
        
        # Map to confidence levels
        if adjusted_confidence >= 0.90:
            return DecisionConfidence.VERY_HIGH
        elif adjusted_confidence >= 0.75:
            return DecisionConfidence.HIGH
        elif adjusted_confidence >= 0.50:
            return DecisionConfidence.MEDIUM
        elif adjusted_confidence >= 0.25:
            return DecisionConfidence.LOW
        else:
            return DecisionConfidence.VERY_LOW

class DecisionRecommendationEngine:
    """Engine for generating decision recommendations based on integrated analysis"""
    
    def __init__(self):
        self.recommendation_thresholds = {
            RecommendationType.PURSUE_IMMEDIATELY: 0.80,
            RecommendationType.PURSUE_WITH_PREPARATION: 0.65,
            RecommendationType.CONSIDER_LATER: 0.50,
            RecommendationType.MONITOR_ONLY: 0.35
        }
        
        self.confidence_adjustments = {
            DecisionConfidence.VERY_HIGH: 1.0,
            DecisionConfidence.HIGH: 0.9,
            DecisionConfidence.MEDIUM: 0.8,
            DecisionConfidence.LOW: 0.7,
            DecisionConfidence.VERY_LOW: 0.6
        }
    
    async def generate_recommendation(self, 
                                    integrated_score: IntegratedScore,
                                    feasibility: FeasibilityAssessment,
                                    allocation: ResourceAllocation) -> DecisionRecommendation:
        """Generate comprehensive decision recommendation"""
        try:
            # Adjust score based on confidence
            confidence_factor = self.confidence_adjustments[integrated_score.confidence]
            adjusted_score = integrated_score.final_score * confidence_factor
            
            # Incorporate feasibility
            feasibility_factor = feasibility.overall_feasibility
            combined_score = (adjusted_score * 0.6) + (feasibility_factor * 0.4)
            
            # Determine recommendation type
            recommendation_type = self._determine_recommendation_type(combined_score)
            
            # Generate rationale
            rationale = await self._generate_rationale(
                integrated_score, feasibility, allocation, recommendation_type
            )
            
            return DecisionRecommendation(
                opportunity_id=feasibility.opportunity_id,
                recommendation=recommendation_type,
                confidence=integrated_score.confidence,
                priority_score=combined_score,
                integrated_score=integrated_score,
                feasibility_assessment=feasibility,
                resource_allocation=allocation,
                **rationale
            )
            
        except Exception as e:
            logger.error(f"Error generating recommendation: {e}")
            return self._create_error_recommendation(feasibility.opportunity_id, str(e))
    
    def _determine_recommendation_type(self, combined_score: float) -> RecommendationType:
        """Determine recommendation type based on combined score"""
        if combined_score >= self.recommendation_thresholds[RecommendationType.PURSUE_IMMEDIATELY]:
            return RecommendationType.PURSUE_IMMEDIATELY
        elif combined_score >= self.recommendation_thresholds[RecommendationType.PURSUE_WITH_PREPARATION]:
            return RecommendationType.PURSUE_WITH_PREPARATION
        elif combined_score >= self.recommendation_thresholds[RecommendationType.CONSIDER_LATER]:
            return RecommendationType.CONSIDER_LATER
        elif combined_score >= self.recommendation_thresholds[RecommendationType.MONITOR_ONLY]:
            return RecommendationType.MONITOR_ONLY
        else:
            return RecommendationType.AVOID
    
    async def _generate_rationale(self,
                                integrated_score: IntegratedScore,
                                feasibility: FeasibilityAssessment,
                                allocation: ResourceAllocation,
                                recommendation_type: RecommendationType) -> Dict[str, Any]:
        """Generate detailed rationale for the recommendation"""
        
        # Extract key reasons based on scores and feasibility
        primary_reasons = []
        supporting_evidence = []
        concerns = []
        conditions = []
        immediate_actions = []
        preparation_steps = []
        success_metrics = []
        
        # Analyze integrated score components
        high_scoring_components = [c for c in integrated_score.components if c.weighted_score > 0.7]
        low_scoring_components = [c for c in integrated_score.components if c.weighted_score < 0.4]
        
        if high_scoring_components:
            primary_reasons.append(f"Strong performance in {len(high_scoring_components)} key areas")
            for component in high_scoring_components:
                supporting_evidence.append(f"{component.source}: {component.weighted_score:.2f} score")
        
        if low_scoring_components:
            concerns.extend([f"Lower {c.source} score: {c.weighted_score:.2f}" for c in low_scoring_components])
        
        # Feasibility-based rationale
        if feasibility.overall_feasibility > 0.8:
            primary_reasons.append("High overall feasibility assessment")
        elif feasibility.overall_feasibility < 0.5:
            concerns.append("Significant feasibility challenges identified")
        
        # Add feasibility strengths and weaknesses
        supporting_evidence.extend(feasibility.strengths[:3])  # Top 3 strengths
        concerns.extend(feasibility.weaknesses[:3])  # Top 3 concerns
        
        # Resource-based considerations
        if allocation.expected_roi and allocation.expected_roi > 2.0:
            primary_reasons.append(f"Excellent ROI potential: {allocation.expected_roi:.1f}x")
        elif allocation.expected_roi and allocation.expected_roi < 1.0:
            concerns.append(f"Low ROI potential: {allocation.expected_roi:.1f}x")
        
        # Recommendation-specific actions
        if recommendation_type == RecommendationType.PURSUE_IMMEDIATELY:
            immediate_actions = [
                "Begin application preparation immediately",
                "Secure required resources and personnel",
                "Establish project timeline and milestones"
            ]
            success_metrics = [
                "Application submitted by deadline",
                "All compliance requirements met",
                "Resource allocation within budget"
            ]
            
        elif recommendation_type == RecommendationType.PURSUE_WITH_PREPARATION:
            preparation_steps = [
                "Address identified feasibility gaps",
                "Strengthen proposal components",
                "Build necessary partnerships or capabilities"
            ]
            conditions = [
                "Complete preparation activities",
                "Verify resource availability",
                "Confirm strategic alignment"
            ]
            
        elif recommendation_type == RecommendationType.CONSIDER_LATER:
            immediate_actions = [
                "Monitor for changes in opportunity or capabilities",
                "Continue building relevant strengths",
                "Evaluate timing for future application cycles"
            ]
            
        else:  # MONITOR_ONLY or AVOID
            immediate_actions = [
                "Document decision rationale",
                "Monitor for significant changes",
                "Focus resources on higher-priority opportunities"
            ]
        
        # Set review timeline based on recommendation
        review_days = {
            RecommendationType.PURSUE_IMMEDIATELY: 30,
            RecommendationType.PURSUE_WITH_PREPARATION: 90,
            RecommendationType.CONSIDER_LATER: 180,
            RecommendationType.MONITOR_ONLY: 365,
            RecommendationType.AVOID: 365
        }
        
        return {
            'primary_reasons': primary_reasons,
            'supporting_evidence': supporting_evidence,
            'concerns': concerns,
            'conditions': conditions,
            'immediate_actions': immediate_actions,
            'preparation_steps': preparation_steps,
            'success_metrics': success_metrics,
            'review_timeline': timedelta(days=review_days[recommendation_type])
        }
    
    def _create_error_recommendation(self, opportunity_id: str, error_msg: str) -> DecisionRecommendation:
        """Create error fallback recommendation"""
        return DecisionRecommendation(
            opportunity_id=opportunity_id,
            recommendation=RecommendationType.MONITOR_ONLY,
            confidence=DecisionConfidence.VERY_LOW,
            priority_score=0.0,
            integrated_score=IntegratedScore(
                final_score=0.0,
                confidence=DecisionConfidence.VERY_LOW,
                components=[],
                weights={},
                integration_method='error_fallback'
            ),
            feasibility_assessment=FeasibilityAssessment(
                opportunity_id=opportunity_id,
                overall_feasibility=0.0,
                confidence=DecisionConfidence.VERY_LOW,
                technical_feasibility=0.0,
                resource_feasibility=0.0,
                timeline_feasibility=0.0,
                compliance_feasibility=0.0,
                strategic_alignment=0.0,
                strengths=[],
                weaknesses=[f"Analysis error: {error_msg}"],
                requirements=[],
                risks=[],
                mitigation_strategies=[]
            ),
            resource_allocation=ResourceAllocation(
                opportunity_id=opportunity_id,
                recommended_allocation={},
                priority_ranking=999,
                expected_roi=None,
                recommended_timeline={},
                critical_path=[],
                resource_conflicts=[],
                strategic_value=0.0,
                risk_adjusted_value=0.0,
                opportunity_cost=None
            ),
            primary_reasons=[f"Analysis failed: {error_msg}"],
            supporting_evidence=[],
            concerns=["Unable to complete analysis"],
            conditions=["Resolve analysis issues before proceeding"],
            immediate_actions=["Investigate analysis failure"],
            preparation_steps=["Fix analysis pipeline"],
            success_metrics=["Successful analysis completion"],
            review_timeline=timedelta(days=30)
        )

class FeasibilityAssessmentEngine:
    """Engine for comprehensive feasibility assessment"""
    
    def __init__(self):
        self.assessment_weights = {
            'technical': 0.25,      # Technical capability assessment
            'resource': 0.25,       # Resource availability assessment  
            'timeline': 0.20,       # Timeline feasibility assessment
            'compliance': 0.20,     # Compliance capability assessment
            'strategic': 0.10       # Strategic alignment assessment
        }
    
    async def assess_feasibility(self, 
                               opportunity_id: str,
                               opportunity_data: Dict[str, Any],
                               organizational_profile: Dict[str, Any]) -> FeasibilityAssessment:
        """Conduct comprehensive feasibility assessment"""
        try:
            logger.info(f"Assessing feasibility for opportunity {opportunity_id}")
            
            # Individual dimension assessments
            technical = await self._assess_technical_feasibility(opportunity_data, organizational_profile)
            resource = await self._assess_resource_feasibility(opportunity_data, organizational_profile)
            timeline = await self._assess_timeline_feasibility(opportunity_data, organizational_profile)
            compliance = await self._assess_compliance_feasibility(opportunity_data, organizational_profile)
            strategic = await self._assess_strategic_alignment(opportunity_data, organizational_profile)
            
            # Calculate overall feasibility
            overall = (
                technical * self.assessment_weights['technical'] +
                resource * self.assessment_weights['resource'] +
                timeline * self.assessment_weights['timeline'] +
                compliance * self.assessment_weights['compliance'] +
                strategic * self.assessment_weights['strategic']
            )
            
            # Determine confidence based on data completeness
            confidence = self._calculate_assessment_confidence(opportunity_data, organizational_profile)
            
            # Generate detailed analysis
            analysis = await self._generate_detailed_analysis(
                opportunity_data, organizational_profile, 
                technical, resource, timeline, compliance, strategic
            )
            
            return FeasibilityAssessment(
                opportunity_id=opportunity_id,
                overall_feasibility=overall,
                confidence=confidence,
                technical_feasibility=technical,
                resource_feasibility=resource,
                timeline_feasibility=timeline,
                compliance_feasibility=compliance,
                strategic_alignment=strategic,
                **analysis
            )
            
        except Exception as e:
            logger.error(f"Error assessing feasibility for {opportunity_id}: {e}")
            return self._create_error_assessment(opportunity_id, str(e))
    
    async def _assess_technical_feasibility(self, opp_data: Dict[str, Any], org_profile: Dict[str, Any]) -> float:
        """Assess technical capability to execute the opportunity"""
        technical_score = 0.7  # Default moderate score
        
        # Check program areas alignment
        opp_areas = opp_data.get('program_areas', [])
        org_capabilities = org_profile.get('program_areas', [])
        
        if opp_areas and org_capabilities:
            overlap = len(set(opp_areas) & set(org_capabilities))
            technical_score = min(1.0, overlap / len(opp_areas) + 0.3)
        
        # Adjust for organizational size and capacity
        org_revenue = org_profile.get('annual_revenue', 0)
        if org_revenue > 1000000:  # Large organization
            technical_score += 0.1
        elif org_revenue < 100000:  # Small organization
            technical_score -= 0.1
        
        return max(0.0, min(1.0, technical_score))
    
    async def _assess_resource_feasibility(self, opp_data: Dict[str, Any], org_profile: Dict[str, Any]) -> float:
        """Assess resource availability and capacity"""
        resource_score = 0.6  # Default moderate score
        
        # Budget feasibility
        award_amount = opp_data.get('award_amount', 0)
        org_budget = org_profile.get('annual_revenue', 0)
        
        if award_amount and org_budget:
            if award_amount <= org_budget * 0.5:  # Award is manageable size
                resource_score += 0.2
            elif award_amount > org_budget * 2.0:  # Award is very large
                resource_score -= 0.2
        
        # Staff capacity indicators
        org_employees = org_profile.get('employee_count', 0)
        if org_employees > 50:  # Larger staff capacity
            resource_score += 0.15
        elif org_employees < 5:  # Very small staff
            resource_score -= 0.15
        
        return max(0.0, min(1.0, resource_score))
    
    async def _assess_timeline_feasibility(self, opp_data: Dict[str, Any], org_profile: Dict[str, Any]) -> float:
        """Assess timeline and scheduling feasibility"""
        timeline_score = 0.7  # Default moderate score
        
        # Application deadline pressure
        deadline = opp_data.get('application_deadline')
        if deadline:
            try:
                deadline_date = datetime.fromisoformat(deadline.replace('Z', '+00:00'))
                days_until_deadline = (deadline_date - datetime.now()).days
                
                if days_until_deadline > 60:  # Plenty of time
                    timeline_score += 0.2
                elif days_until_deadline < 14:  # Very tight deadline
                    timeline_score -= 0.3
                elif days_until_deadline < 30:  # Moderately tight
                    timeline_score -= 0.1
                    
            except (ValueError, TypeError):
                pass  # Could not parse deadline
        
        # Project duration feasibility
        project_duration = opp_data.get('project_duration_months', 12)
        if project_duration <= 12:  # Short-term project
            timeline_score += 0.1
        elif project_duration > 36:  # Long-term commitment
            timeline_score -= 0.1
        
        return max(0.0, min(1.0, timeline_score))
    
    async def _assess_compliance_feasibility(self, opp_data: Dict[str, Any], org_profile: Dict[str, Any]) -> float:
        """Assess compliance and regulatory feasibility"""
        compliance_score = 0.8  # Default optimistic score
        
        # Check basic eligibility requirements
        eligibility_reqs = opp_data.get('eligibility_requirements', [])
        
        # 501(c)(3) requirement check
        if 'nonprofit' in str(eligibility_reqs).lower():
            if org_profile.get('organization_type') == 'nonprofit':
                compliance_score += 0.1
            else:
                compliance_score -= 0.4
        
        # Geographic eligibility
        eligible_states = opp_data.get('eligible_states', [])
        org_state = org_profile.get('state')
        if eligible_states and org_state:
            if org_state in eligible_states:
                compliance_score += 0.05
            else:
                compliance_score -= 0.3
        
        # Audit requirements
        if opp_data.get('requires_audit', False):
            if org_profile.get('annual_revenue', 0) > 750000:  # Likely has audit capability
                compliance_score += 0.05
            else:
                compliance_score -= 0.2
        
        return max(0.0, min(1.0, compliance_score))
    
    async def _assess_strategic_alignment(self, opp_data: Dict[str, Any], org_profile: Dict[str, Any]) -> float:
        """Assess strategic alignment with organizational mission"""
        strategic_score = 0.6  # Default moderate score
        
        # Mission alignment
        opp_description = opp_data.get('description', '').lower()
        org_mission = org_profile.get('mission', '').lower()
        
        if org_mission and opp_description:
            # Simple keyword overlap analysis
            mission_keywords = set(org_mission.split())
            desc_keywords = set(opp_description.split())
            overlap = len(mission_keywords & desc_keywords)
            
            if overlap > 5:  # Good keyword overlap
                strategic_score += 0.3
            elif overlap > 2:  # Some overlap
                strategic_score += 0.1
        
        # NTEE code alignment
        opp_ntee = opp_data.get('ntee_codes', [])
        org_ntee = org_profile.get('ntee_codes', [])
        
        if opp_ntee and org_ntee:
            ntee_overlap = len(set(opp_ntee) & set(org_ntee))
            if ntee_overlap > 0:
                strategic_score += 0.2
        
        return max(0.0, min(1.0, strategic_score))
    
    def _calculate_assessment_confidence(self, opp_data: Dict[str, Any], org_profile: Dict[str, Any]) -> DecisionConfidence:
        """Calculate confidence level for the assessment"""
        
        # Count available data points
        opp_completeness = sum([
            bool(opp_data.get('description')),
            bool(opp_data.get('eligibility_requirements')),
            bool(opp_data.get('award_amount')),
            bool(opp_data.get('application_deadline')),
            bool(opp_data.get('program_areas'))
        ]) / 5.0
        
        org_completeness = sum([
            bool(org_profile.get('mission')),
            bool(org_profile.get('program_areas')),
            bool(org_profile.get('annual_revenue')),
            bool(org_profile.get('organization_type')),
            bool(org_profile.get('state'))
        ]) / 5.0
        
        overall_completeness = (opp_completeness + org_completeness) / 2.0
        
        # Map completeness to confidence levels
        if overall_completeness >= 0.9:
            return DecisionConfidence.VERY_HIGH
        elif overall_completeness >= 0.7:
            return DecisionConfidence.HIGH
        elif overall_completeness >= 0.5:
            return DecisionConfidence.MEDIUM
        elif overall_completeness >= 0.3:
            return DecisionConfidence.LOW
        else:
            return DecisionConfidence.VERY_LOW
    
    async def _generate_detailed_analysis(self, opp_data: Dict[str, Any], org_profile: Dict[str, Any],
                                        technical: float, resource: float, timeline: float,
                                        compliance: float, strategic: float) -> Dict[str, Any]:
        """Generate detailed strengths, weaknesses, requirements, and risks"""
        
        strengths = []
        weaknesses = []
        requirements = []
        risks = []
        mitigation_strategies = []
        
        # Technical analysis
        if technical > 0.8:
            strengths.append("Strong technical capabilities and program area alignment")
        elif technical < 0.5:
            weaknesses.append("Limited technical capabilities for this opportunity type")
            requirements.append("Develop technical expertise in relevant program areas")
        
        # Resource analysis
        if resource > 0.8:
            strengths.append("Adequate resources and organizational capacity")
        elif resource < 0.5:
            weaknesses.append("Resource constraints may limit execution capability")
            risks.append("Resource shortage could impact project delivery")
            mitigation_strategies.append("Secure additional funding or partnerships")
        
        # Timeline analysis
        if timeline > 0.8:
            strengths.append("Favorable timeline with adequate preparation time")
        elif timeline < 0.5:
            weaknesses.append("Tight timeline creates execution pressure")
            risks.append("Time constraints may compromise application quality")
            mitigation_strategies.append("Prioritize critical application components")
        
        # Compliance analysis
        if compliance > 0.8:
            strengths.append("Strong compliance posture and eligibility alignment")
        elif compliance < 0.5:
            weaknesses.append("Compliance gaps or eligibility concerns")
            requirements.append("Address regulatory and compliance requirements")
            risks.append("Non-compliance could result in application rejection")
        
        # Strategic analysis
        if strategic > 0.8:
            strengths.append("Excellent strategic alignment with organizational mission")
        elif strategic < 0.5:
            weaknesses.append("Limited strategic alignment with core mission")
            risks.append("Mission drift risk if opportunity doesn't align with goals")
        
        # Estimate effort and budget
        award_amount = opp_data.get('award_amount', 0)
        estimated_effort = max(100, min(2000, award_amount / 100)) if award_amount else 500
        estimated_budget = award_amount * 0.1 if award_amount else 10000
        
        return {
            'strengths': strengths,
            'weaknesses': weaknesses,
            'requirements': requirements,
            'risks': risks,
            'mitigation_strategies': mitigation_strategies,
            'estimated_effort_hours': int(estimated_effort),
            'required_budget': estimated_budget,
            'key_personnel': ["Grant Manager", "Program Director", "Financial Manager"],
            'external_partnerships': ["Evaluator", "Subject Matter Expert"] if award_amount > 100000 else []
        }
    
    def _create_error_assessment(self, opportunity_id: str, error_msg: str) -> FeasibilityAssessment:
        """Create error fallback assessment"""
        return FeasibilityAssessment(
            opportunity_id=opportunity_id,
            overall_feasibility=0.0,
            confidence=DecisionConfidence.VERY_LOW,
            technical_feasibility=0.0,
            resource_feasibility=0.0,
            timeline_feasibility=0.0,
            compliance_feasibility=0.0,
            strategic_alignment=0.0,
            strengths=[],
            weaknesses=[f"Assessment error: {error_msg}"],
            requirements=["Resolve assessment issues"],
            risks=["Unable to assess opportunity"],
            mitigation_strategies=["Fix assessment pipeline"],
            estimated_effort_hours=None,
            required_budget=None,
            key_personnel=[],
            external_partnerships=[],
            metadata={'error': error_msg}
        )

class ResourceOptimizationEngine:
    """Engine for optimizing resource allocation across opportunities"""
    
    def __init__(self):
        self.resource_weights = {
            ResourceType.STAFF_TIME: 0.35,      # Staff time is most critical
            ResourceType.BUDGET: 0.30,          # Budget allocation important
            ResourceType.EXPERTISE: 0.20,       # Expertise requirements
            ResourceType.PARTNERSHIPS: 0.10,    # Partnership development
            ResourceType.INFRASTRUCTURE: 0.05   # Infrastructure needs
        }
    
    async def optimize_allocation(self,
                                opportunity_id: str,
                                feasibility: FeasibilityAssessment,
                                integrated_score: IntegratedScore,
                                organizational_constraints: Dict[str, Any]) -> ResourceAllocation:
        """Optimize resource allocation for opportunity"""
        try:
            logger.info(f"Optimizing resource allocation for {opportunity_id}")
            
            # Calculate resource requirements
            resource_requirements = await self._calculate_resource_requirements(feasibility)
            
            # Optimize allocation based on constraints
            optimized_allocation = await self._optimize_allocation_strategy(
                resource_requirements, organizational_constraints
            )
            
            # Calculate priority ranking
            priority = await self._calculate_priority_ranking(integrated_score, feasibility)
            
            # Estimate ROI
            roi = await self._estimate_roi(feasibility, integrated_score)
            
            # Generate timeline optimization
            timeline = await self._optimize_timeline(feasibility, organizational_constraints)
            
            # Calculate strategic metrics
            strategic_value = await self._calculate_strategic_value(feasibility, integrated_score)
            risk_adjusted_value = strategic_value * feasibility.overall_feasibility
            
            return ResourceAllocation(
                opportunity_id=opportunity_id,
                recommended_allocation=optimized_allocation,
                priority_ranking=priority,
                expected_roi=roi,
                recommended_timeline=timeline,
                critical_path=await self._identify_critical_path(feasibility),
                resource_conflicts=await self._identify_conflicts(resource_requirements, organizational_constraints),
                strategic_value=strategic_value,
                risk_adjusted_value=risk_adjusted_value,
                opportunity_cost=await self._calculate_opportunity_cost(integrated_score, feasibility)
            )
            
        except Exception as e:
            logger.error(f"Error optimizing allocation for {opportunity_id}: {e}")
            return self._create_error_allocation(opportunity_id, str(e))
    
    async def _calculate_resource_requirements(self, feasibility: FeasibilityAssessment) -> Dict[ResourceType, float]:
        """Calculate base resource requirements"""
        requirements = {}
        
        # Staff time based on effort estimate
        if feasibility.estimated_effort_hours:
            requirements[ResourceType.STAFF_TIME] = min(1.0, feasibility.estimated_effort_hours / 1000)
        else:
            requirements[ResourceType.STAFF_TIME] = 0.5  # Default moderate requirement
        
        # Budget based on estimated requirement
        if feasibility.required_budget:
            # Normalize based on typical grant size (assume $100k baseline)
            requirements[ResourceType.BUDGET] = min(1.0, feasibility.required_budget / 100000)
        else:
            requirements[ResourceType.BUDGET] = 0.4  # Default moderate requirement
        
        # Expertise based on complexity factors
        complexity_indicators = [
            feasibility.compliance_feasibility < 0.7,  # Complex compliance
            feasibility.technical_feasibility < 0.6,   # Technical challenges
            len(feasibility.requirements) > 5          # Many requirements
        ]
        expertise_need = sum(complexity_indicators) / len(complexity_indicators)
        requirements[ResourceType.EXPERTISE] = expertise_need
        
        # Partnerships based on external partnership needs
        partnership_need = len(feasibility.external_partnerships) / 5.0  # Normalize to 0-1
        requirements[ResourceType.PARTNERSHIPS] = min(1.0, partnership_need)
        
        # Infrastructure based on award size and duration
        infrastructure_need = 0.3  # Default low-moderate need
        if feasibility.required_budget and feasibility.required_budget > 500000:
            infrastructure_need = 0.7  # Higher need for large awards
        requirements[ResourceType.INFRASTRUCTURE] = infrastructure_need
        
        return requirements
    
    async def _optimize_allocation_strategy(self,
                                          requirements: Dict[ResourceType, float],
                                          constraints: Dict[str, Any]) -> Dict[ResourceType, float]:
        """Optimize allocation strategy based on requirements and constraints"""
        
        # Apply organizational capacity constraints
        available_capacity = constraints.get('available_capacity', {})
        
        optimized = {}
        for resource_type, required in requirements.items():
            # Check against available capacity
            capacity = available_capacity.get(resource_type.value, 1.0)  # Default full capacity
            
            # Allocate based on both requirement and capacity
            allocated = min(required, capacity)
            
            # Apply strategic weighting
            weight = self.resource_weights[resource_type]
            optimized[resource_type] = allocated * weight
        
        # Normalize allocations to sum to 1.0
        total = sum(optimized.values())
        if total > 0:
            optimized = {k: v/total for k, v in optimized.items()}
        
        return optimized
    
    async def _calculate_priority_ranking(self, integrated_score: IntegratedScore, feasibility: FeasibilityAssessment) -> int:
        """Calculate priority ranking (1 = highest priority)"""
        # Combine score and feasibility
        combined_score = (integrated_score.final_score * 0.6) + (feasibility.overall_feasibility * 0.4)
        
        # Convert to ranking (1-10 scale, 1 = highest)
        ranking = max(1, min(10, 11 - int(combined_score * 10)))
        
        return ranking
    
    async def _estimate_roi(self, feasibility: FeasibilityAssessment, integrated_score: IntegratedScore) -> Optional[float]:
        """Estimate return on investment"""
        if not feasibility.required_budget or feasibility.required_budget <= 0:
            return None
        
        # Simple ROI estimation based on award amount and probability of success
        award_amount = feasibility.estimated_effort_hours * 100 if feasibility.estimated_effort_hours else 50000
        investment = feasibility.required_budget
        success_probability = (integrated_score.final_score + feasibility.overall_feasibility) / 2
        
        expected_return = award_amount * success_probability
        roi = expected_return / investment if investment > 0 else 0
        
        return max(0.1, roi)  # Minimum 0.1x ROI
    
    async def _optimize_timeline(self, feasibility: FeasibilityAssessment, constraints: Dict[str, Any]) -> Dict[str, Any]:
        """Generate optimized timeline structure"""
        
        # Base timeline phases
        phases = {
            'preparation': {'duration_weeks': 4, 'description': 'Initial preparation and planning'},
            'application': {'duration_weeks': 6, 'description': 'Application development and submission'},
            'review_period': {'duration_weeks': 12, 'description': 'Funder review and decision'},
            'startup': {'duration_weeks': 4, 'description': 'Project startup and initiation'}
        }
        
        # Adjust based on feasibility factors
        if feasibility.timeline_feasibility < 0.5:
            # Accelerate timeline if deadline pressure
            phases['preparation']['duration_weeks'] = 2
            phases['application']['duration_weeks'] = 4
        
        if feasibility.compliance_feasibility < 0.6:
            # Add time for compliance work
            phases['preparation']['duration_weeks'] += 2
        
        # Calculate total timeline
        total_weeks = sum(phase['duration_weeks'] for phase in phases.values())
        
        return {
            'phases': phases,
            'total_duration_weeks': total_weeks,
            'start_date': datetime.now().isoformat(),
            'estimated_completion': (datetime.now() + timedelta(weeks=total_weeks)).isoformat()
        }
    
    async def _identify_critical_path(self, feasibility: FeasibilityAssessment) -> List[str]:
        """Identify critical path milestones"""
        critical_path = [
            "Secure organizational commitment",
            "Develop project concept and design",
            "Complete compliance requirements"
        ]
        
        if feasibility.external_partnerships:
            critical_path.insert(1, "Establish required partnerships")
        
        if feasibility.technical_feasibility < 0.7:
            critical_path.insert(-1, "Address technical capability gaps")
        
        critical_path.extend([
            "Prepare and submit application",
            "Respond to funder questions",
            "Negotiate award terms",
            "Begin project implementation"
        ])
        
        return critical_path
    
    async def _identify_conflicts(self, requirements: Dict[ResourceType, float], constraints: Dict[str, Any]) -> List[str]:
        """Identify potential resource conflicts"""
        conflicts = []
        
        capacity = constraints.get('available_capacity', {})
        
        for resource_type, required in requirements.items():
            available = capacity.get(resource_type.value, 1.0)
            
            if required > available * 1.2:  # Significantly over capacity
                conflicts.append(f"High {resource_type.value} demand exceeds available capacity")
            elif required > available:  # Moderately over capacity
                conflicts.append(f"Moderate {resource_type.value} constraint identified")
        
        # Check for timing conflicts
        if constraints.get('concurrent_projects', 0) > 3:
            conflicts.append("Multiple concurrent projects may strain resources")
        
        return conflicts
    
    async def _calculate_strategic_value(self, feasibility: FeasibilityAssessment, integrated_score: IntegratedScore) -> float:
        """Calculate strategic value score"""
        # Combine strategic alignment with overall opportunity quality
        strategic_component = feasibility.strategic_alignment * 0.4
        quality_component = integrated_score.final_score * 0.3
        feasibility_component = feasibility.overall_feasibility * 0.3
        
        return strategic_component + quality_component + feasibility_component
    
    async def _calculate_opportunity_cost(self, integrated_score: IntegratedScore, feasibility: FeasibilityAssessment) -> Optional[float]:
        """Calculate opportunity cost of pursuing this vs others"""
        # Simplified opportunity cost calculation
        # In reality, this would compare against other opportunities in the pipeline
        
        if feasibility.required_budget and feasibility.required_budget > 0:
            # Cost per point of integrated score
            cost_per_point = feasibility.required_budget / (integrated_score.final_score * 100)
            return cost_per_point
        
        return None
    
    def _create_error_allocation(self, opportunity_id: str, error_msg: str) -> ResourceAllocation:
        """Create error fallback allocation"""
        return ResourceAllocation(
            opportunity_id=opportunity_id,
            recommended_allocation={
                ResourceType.STAFF_TIME: 0.4,
                ResourceType.BUDGET: 0.3,
                ResourceType.EXPERTISE: 0.2,
                ResourceType.PARTNERSHIPS: 0.1,
                ResourceType.INFRASTRUCTURE: 0.0
            },
            priority_ranking=999,
            expected_roi=None,
            recommended_timeline={'error': error_msg, 'total_duration_weeks': 0},
            critical_path=["Resolve allocation error"],
            resource_conflicts=[f"Allocation error: {error_msg}"],
            strategic_value=0.0,
            risk_adjusted_value=0.0,
            opportunity_cost=None,
            metadata={'error': error_msg}
        )

class DecisionSynthesisFramework(BaseProcessor):
    """Main framework for comprehensive decision synthesis"""
    
    def __init__(self):
        super().__init__()
        self.integration_system = MultiScoreIntegrationSystem()
        self.recommendation_engine = DecisionRecommendationEngine()
        self.feasibility_engine = FeasibilityAssessmentEngine()
        self.optimization_engine = ResourceOptimizationEngine()
        
        # Integration with existing systems
        self.workflow_scorer = WorkflowAwareGovernmentScorer()
        self.research_integration = GovernmentResearchIntegration()
        self.compliance_generator = ComplianceRoadmapGenerator()
    
    async def process(self, profile_id: str, **kwargs) -> Dict[str, Any]:
        """Process comprehensive decision synthesis for profile opportunities"""
        try:
            logger.info(f"Starting decision synthesis for profile {profile_id}")
            
            # Get profile data and opportunities
            profile_data = await self._load_profile_data(profile_id)
            opportunities = await self._load_opportunities(profile_id)
            
            if not opportunities:
                return {
                    'profile_id': profile_id,
                    'recommendations': [],
                    'summary': 'No opportunities available for analysis',
                    'timestamp': datetime.now().isoformat()
                }
            
            # Process each opportunity
            recommendations = []
            for opp_id, opp_data in opportunities.items():
                try:
                    recommendation = await self.synthesize_decision(
                        opportunity_id=opp_id,
                        opportunity_data=opp_data,
                        profile_data=profile_data
                    )
                    recommendations.append(recommendation)
                    
                except Exception as e:
                    logger.error(f"Error processing opportunity {opp_id}: {e}")
                    continue
            
            # Sort by priority score
            recommendations.sort(key=lambda x: x.priority_score, reverse=True)
            
            # Generate summary
            summary = await self._generate_synthesis_summary(recommendations)
            
            return {
                'profile_id': profile_id,
                'recommendations': [self._serialize_recommendation(r) for r in recommendations],
                'summary': summary,
                'total_opportunities': len(opportunities),
                'processed_successfully': len(recommendations),
                'timestamp': datetime.now().isoformat(),
                'metadata': {
                    'framework_version': '1.0',
                    'processing_duration': kwargs.get('processing_time', 0)
                }
            }
            
        except Exception as e:
            logger.error(f"Error in decision synthesis framework: {e}")
            return {
                'profile_id': profile_id,
                'recommendations': [],
                'summary': f'Processing error: {str(e)}',
                'error': str(e),
                'timestamp': datetime.now().isoformat()
            }
    
    async def synthesize_decision(self,
                                 opportunity_id: str,
                                 opportunity_data: Dict[str, Any],
                                 profile_data: Dict[str, Any]) -> DecisionRecommendation:
        """Synthesize comprehensive decision for a single opportunity"""
        
        # Step 1: Collect score components from various systems
        score_components = await self._collect_score_components(opportunity_id, opportunity_data, profile_data)
        
        # Step 2: Integrate scores
        integrated_score = await self.integration_system.integrate_scores(opportunity_id, score_components)
        
        # Step 3: Assess feasibility
        feasibility = await self.feasibility_engine.assess_feasibility(
            opportunity_id, opportunity_data, profile_data
        )
        
        # Step 4: Optimize resource allocation
        organizational_constraints = await self._get_organizational_constraints(profile_data)
        resource_allocation = await self.optimization_engine.optimize_allocation(
            opportunity_id, feasibility, integrated_score, organizational_constraints
        )
        
        # Step 5: Generate comprehensive recommendation
        recommendation = await self.recommendation_engine.generate_recommendation(
            integrated_score, feasibility, resource_allocation
        )
        
        return recommendation
    
    async def _collect_score_components(self,
                                      opportunity_id: str,
                                      opportunity_data: Dict[str, Any],
                                      profile_data: Dict[str, Any]) -> List[ScoreComponent]:
        """Collect score components from various analysis systems"""
        components = []
        
        try:
            # Workflow-aware government scoring
            workflow_result = await self.workflow_scorer.process_opportunity(opportunity_id, opportunity_data)
            if workflow_result and 'enhanced_score' in workflow_result:
                components.append(ScoreComponent(
                    source='workflow_aware',
                    raw_score=workflow_result['enhanced_score'].base_score,
                    weighted_score=0.0,  # Will be set by integration system
                    confidence=workflow_result['enhanced_score'].confidence_score,
                    metadata=workflow_result.get('metadata', {})
                ))
            
            # AI-based analysis components would be added here
            # For now, we'll simulate with placeholder components
            
            # Government research integration
            research_result = await self.research_integration.analyze_opportunity(opportunity_id, opportunity_data)
            if research_result and 'analysis_score' in research_result:
                components.append(ScoreComponent(
                    source='government_research',
                    raw_score=research_result['analysis_score'],
                    weighted_score=0.0,
                    confidence=research_result.get('confidence', 0.7),
                    metadata=research_result.get('metadata', {})
                ))
            
            # Compliance analysis
            compliance_result = await self.compliance_generator.assess_compliance_fit(
                opportunity_id, opportunity_data, profile_data
            )
            if compliance_result and 'compliance_score' in compliance_result:
                components.append(ScoreComponent(
                    source='compliance',
                    raw_score=compliance_result['compliance_score'],
                    weighted_score=0.0,
                    confidence=compliance_result.get('confidence', 0.8),
                    metadata=compliance_result.get('metadata', {})
                ))
            
        except Exception as e:
            logger.error(f"Error collecting score components for {opportunity_id}: {e}")
        
        # Ensure we have at least one component for integration
        if not components:
            components.append(ScoreComponent(
                source='baseline',
                raw_score=0.5,  # Neutral baseline
                weighted_score=0.0,
                confidence=0.3,
                metadata={'note': 'Fallback baseline component'}
            ))
        
        return components
    
    async def _load_profile_data(self, profile_id: str) -> Dict[str, Any]:
        """Load profile data for analysis"""
        try:
            # This would typically load from profile storage
            # For now, return a default structure
            return {
                'profile_id': profile_id,
                'organization_type': 'nonprofit',
                'annual_revenue': 500000,
                'employee_count': 25,
                'state': 'VA',
                'mission': 'Supporting community development and education',
                'program_areas': ['education', 'community_development', 'youth_services'],
                'ntee_codes': ['P20', 'S20', 'Y01']
            }
        except Exception as e:
            logger.error(f"Error loading profile data for {profile_id}: {e}")
            return {'profile_id': profile_id}
    
    async def _load_opportunities(self, profile_id: str) -> Dict[str, Dict[str, Any]]:
        """Load opportunities for the profile"""
        try:
            # This would typically load discovered opportunities
            # For now, return empty dict - opportunities would come from discovery system
            entity_cache = get_entity_cache_manager()
            
            # Try to get government opportunities from cache
            govt_opportunities = {}
            cache_key = f"government_opportunities_{profile_id}"
            cached_data = entity_cache.get_cached_data(cache_key)
            
            if cached_data and 'opportunities' in cached_data:
                govt_opportunities = cached_data['opportunities']
            
            return govt_opportunities
            
        except Exception as e:
            logger.error(f"Error loading opportunities for {profile_id}: {e}")
            return {}
    
    async def _get_organizational_constraints(self, profile_data: Dict[str, Any]) -> Dict[str, Any]:
        """Get organizational constraints for resource optimization"""
        
        # Default capacity based on organization size
        annual_revenue = profile_data.get('annual_revenue', 0)
        employee_count = profile_data.get('employee_count', 0)
        
        # Calculate capacity factors
        if annual_revenue > 1000000:  # Large organization
            base_capacity = 0.9
        elif annual_revenue > 500000:  # Medium organization
            base_capacity = 0.7
        elif annual_revenue > 100000:  # Small organization
            base_capacity = 0.5
        else:  # Very small organization
            base_capacity = 0.3
        
        return {
            'available_capacity': {
                'staff_time': base_capacity,
                'budget': min(1.0, annual_revenue / 100000),
                'expertise': base_capacity * 0.8,  # Slightly lower expertise capacity
                'partnerships': 0.6,  # Moderate partnership capacity
                'infrastructure': base_capacity * 0.7
            },
            'concurrent_projects': min(5, max(1, employee_count // 10)),
            'risk_tolerance': 0.6,  # Moderate risk tolerance
            'timeline_flexibility': 0.5  # Moderate timeline flexibility
        }
    
    async def _generate_synthesis_summary(self, recommendations: List[DecisionRecommendation]) -> Dict[str, Any]:
        """Generate high-level summary of synthesis results"""
        if not recommendations:
            return {'message': 'No opportunities processed'}
        
        # Count recommendations by type
        rec_counts = defaultdict(int)
        for rec in recommendations:
            rec_counts[rec.recommendation.value] += 1
        
        # Calculate summary statistics
        avg_priority = sum(r.priority_score for r in recommendations) / len(recommendations)
        high_confidence = sum(1 for r in recommendations if r.confidence in [DecisionConfidence.HIGH, DecisionConfidence.VERY_HIGH])
        
        return {
            'total_analyzed': len(recommendations),
            'recommendation_distribution': dict(rec_counts),
            'average_priority_score': round(avg_priority, 3),
            'high_confidence_count': high_confidence,
            'high_confidence_percentage': round(high_confidence / len(recommendations) * 100, 1),
            'top_recommendation': recommendations[0].opportunity_id if recommendations else None
        }
    
    def _serialize_recommendation(self, recommendation: DecisionRecommendation) -> Dict[str, Any]:
        """Serialize recommendation for JSON output"""
        return {
            'opportunity_id': recommendation.opportunity_id,
            'recommendation': recommendation.recommendation.value,
            'confidence': recommendation.confidence.value,
            'priority_score': recommendation.priority_score,
            'integrated_score': {
                'final_score': recommendation.integrated_score.final_score,
                'confidence': recommendation.integrated_score.confidence.value,
                'components_count': len(recommendation.integrated_score.components),
                'integration_method': recommendation.integrated_score.integration_method
            },
            'feasibility_assessment': {
                'overall_feasibility': recommendation.feasibility_assessment.overall_feasibility,
                'technical_feasibility': recommendation.feasibility_assessment.technical_feasibility,
                'resource_feasibility': recommendation.feasibility_assessment.resource_feasibility,
                'timeline_feasibility': recommendation.feasibility_assessment.timeline_feasibility,
                'compliance_feasibility': recommendation.feasibility_assessment.compliance_feasibility,
                'strategic_alignment': recommendation.feasibility_assessment.strategic_alignment,
                'strengths_count': len(recommendation.feasibility_assessment.strengths),
                'concerns_count': len(recommendation.feasibility_assessment.weaknesses)
            },
            'resource_allocation': {
                'priority_ranking': recommendation.resource_allocation.priority_ranking,
                'expected_roi': recommendation.resource_allocation.expected_roi,
                'strategic_value': recommendation.resource_allocation.strategic_value,
                'resource_conflicts_count': len(recommendation.resource_allocation.resource_conflicts)
            },
            'rationale': {
                'primary_reasons': recommendation.primary_reasons,
                'immediate_actions': recommendation.immediate_actions,
                'success_metrics': recommendation.success_metrics,
                'review_timeline_days': recommendation.review_timeline.days
            },
            'timestamp': recommendation.timestamp.isoformat()
        }

# Export main framework for use in other modules
__all__ = [
    'DecisionSynthesisFramework',
    'DecisionRecommendation', 
    'IntegratedScore',
    'FeasibilityAssessment',
    'ResourceAllocation',
    'RecommendationType',
    'DecisionConfidence'
]